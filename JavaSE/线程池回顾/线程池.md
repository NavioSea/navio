## 线程池

#### `1.JUC 包下 Excutors（创建线程池的方式）`

```
1.newFixedThreadPool（定长线程池）可重用固定线程数

2. newWorkStealingPool （工作窃取 ）

3.newSingleThreadExecutor (单个线程的线程池)

4. newScheduledThreadPool  （创建一个线程池,在给定延迟后运行命令或定期执行）

5.newSingleThreadScheduledExecutor（创业一个单线程，在给定延迟后运行命令或定期执行）

6.newCacheThreadPool(可缓存重复利用的线程池)


```

2.核心参数

``` 
1.corePoolSize 核心线程数
2.maximumPoolSize 创建线程最大个数
3.keepAliveTime 空闲线程存活时间
4.TimeUnit
- 选项
TimeUnit.DAYS //天
TimeUnit.HOURS //小时
TimeUnit.MINUTES //分钟
TimeUnit.SECONDS //秒
TimeUnit.MILLISECONDS //毫秒
TimeUnit.NANOSECONDS //毫微秒
TimeUnit.MICROSECONDS //微秒
- 时间
5.workQueue 工作队列(ArrayBlockingQueue|DelayQueue|LinkedBlockingQueue|PriorityBolckingQueue|SynchronousQueue)
6.threadFactory 创建线程的工厂(指定线程名称)
7.handler 策略
```

#### 2.线程池执行流程

1.线程池想要执行任务,首先保证的是核心线程数有空闲。

2.如果核心线程池没有空闲,会把任务放到阻塞队列中排队。

3.如果阻塞队列已满,回去查看工作线程数是否为`最大线程数`，创建非核心线程数。

4.如果已达最大线程数,执行拒绝策略。

![image-20220603015238813](C:\Users\lzh\AppData\Roaming\Typora\typora-user-images\image-20220603015238813.png)

#### 3.线程池属性标识（`ThreadPoolExecutor`）

1.线程池核心属性

```java
//该属性表达了两个意思:1.声明当前线程池的状态 2.声明线程池中的线程数
//高3位是:线程池状态 低29位是:线程池中的线程个数
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    private static final int COUNT_BITS = Integer.SIZE - 3;//它的值是29,方便后边做位运算
    private static final int CAPACITY   = (1 << COUNT_BITS) - 1;//通过位运算得出最大容量
    // runState is stored in the high-order bits
	//线程池状态
    private static final int RUNNING    = -1 << COUNT_BITS;//111 代表Running
    private static final int SHUTDOWN   =  0 << COUNT_BITS;//000 代表线程池为Shutdown状态:不会接受新的任务,执行正常任务和阻塞任务
    private static final int STOP       =  1 << COUNT_BITS;//001 代表线程池 为Stop状态，不会接收新任务,也不会去处理阻塞队列中的任务,同时会中断正在执行的任务
    private static final int TIDYING    =  2 << COUNT_BITS;//010 代表线程池为Tidying 过渡状态,线程池即将Game Over
    private static final int TERMINATED =  3 << COUNT_BITS;//011 代表线程池为TERMINATED状态,线程池Game Over（需要执行terminated()方法） 

    // Packing and unpacking ctl
    private static int runStateOf(int c)     { return c & ~CAPACITY; }//得到线程池的状态
    private static int workerCountOf(int c)  { return c & CAPACITY; }//得到当前线程池的线程数量
    private static int ctlOf(int rs, int wc) { return rs | wc; }
```

2.线程池状态变化

1) RUNNING:运行状态,正常接受任务

2) SHUTDOWN:关闭状态,不会接受新的任务,执行正常任务和阻塞队列任务

3) STOP:停止状态,不接受新任务，不可以处理阻塞队列，中断正在执行的队列

4) TIDYING:过渡状态

```
- 当SHUTDOWN状态队列为空,工作线程为空,转换到过渡状态
- 当STOP状态工作线程全空,转换到过渡状态
```

5) TERMINATED:结束状态；

![image-20220603175317555](img\image-20220603175317555.png)

#### 4.从execute方法开始

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
   	//获取到32位的int
    int c = ctl.get();
    //获取到工作线程数小于核心线程数
    if (workerCountOf(c) < corePoolSize) {
        //进入到if，代表可以创建 核心 线程数
        if (addWorker(command, true))
            return;
        //如果if判断未进入,代表核心线程数失败,重新获取ctl
        c = ctl.get();
    }
    // 判断线程池状态是否是运行状态,将任务添加到阻塞队列
    if (isRunning(c) && workQueue.offer(command)) {
        //再次获取是否是RUNNING状态
        int recheck = ctl.get();
        //再次判断是否是Runnig状态,如果不是Running，移除任务
        if (! isRunning(recheck) && remove(command))
            //执行拒绝策略
            reject(command);
        //如果线程池处于Running状态,but工作线程为0
        else if (workerCountOf(recheck) == 0)
            //阻塞队列有任务，但是没有工作线程,添加一个任务为空的工作线程处理阻塞队列中的任务
            addWorker(null, false);	
    }
    //如果创建 非核心线程失败
    else if (!addWorker(command, false))
        //拒绝策略
        reject(command);
}
```

###### addworker

```java
private boolean addWorker(Runnable firstTask, boolean core) {
    	//标记for循环，方便内部for循环跳出
        retry:
    //经过大量的判断,给线程数+1
        for (;;) {
           	//获取ctl
            int c = ctl.get();
             //获取线程池状态
            int rs = runStateOf(c);

            // 除了RUNNING都有可能
            if (rs >= SHUTDOWN &&
                ! (rs == SHUTDOWN &&
                   firstTask == null &&
                   ! workQueue.isEmpty()))
                //rs 线程池状态是关闭状态，如果不是SHUTDOWN,代表就是STOP或更高级状态,不需要添加线程处理任务
                //任务为null,如果任务不 为null，并且线程池状态不是RUNNING,不需要处理 
                //如果阻塞队列为空,不需要创建线程池
                
                //创建工作线程失败
                return false;

            for (;;) {
                //获取工作线程
                int wc = workerCountOf(c);
                //如果当前线程已经大于等于线程池最大容量,不去创建线程了
                if (wc >= CAPACITY ||
                    wc >= (core ? corePoolSize : maximumPoolSize))//判断工作线程数是否超过核心线程数或者最大线程数
                   
                    return false;
                //将工作线程+1,采用CAS的方式
                if (compareAndIncrementWorkerCount(c))
                    //成功退出外侧for循环
                    break retry;
                //有并发操作，重新判断线程池状态
                c = ctl.get();  // Re-read ctl
                //重新判断线程池状态,重新执行,如果状态没变化,循环内侧
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }
		//worker开始
        boolean workerStarted = false;
    	//worker添加
        boolean workerAdded = false;
        Worker w = null;
        try {
            //创建worker
            w = new Worker(firstTask);
            //从worker中获取线程t
            final Thread t = w.thread;
            if (t != null) {
                //加锁(获取线程池的全局锁,避免我添加任务时，其他线程干掉了线程池,干掉线程需要先获取这个锁)
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    //获取线程池状态
                    int rs = runStateOf(ctl.get());
					//线程池是RUNNING状态
                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        //是SHUTDOWN状态需要创建一个空任务工作线程,处理阻塞队列中的任务
                        //线程是否是运行状态
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        //将工作线程添加到集合中
                        workers.add(w);
                        //获取工作线程个数
                        int s = workers.size();
                        //如果线程工作线程数，大于之前记录的最大工作线程数，就替换已选
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        //工作线程添加成功
                        workerAdded = true;
                    }
                } finally {
                    //添加成功后释放锁
                    mainLock.unlock();
                }
                if (workerAdded) {
                    //启动工作线程
                    t.start();
                    //启动工作线程成功
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)//如果启动工作线程失败，调用下面方法
                addWorkerFailed(w);
        }
        return workerStarted;//返回工作是否启动
    }
```

#### workers

```java

    /**
     * Set containing all worker threads in pool. Accessed only when
     * holding mainLock.
     */
    private final HashSet<Worker> workers = new HashSet<Worker>();
```


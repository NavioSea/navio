## 进程和线程

### 1.进程 ###

* 进程是程序的一次执行过程，或是正在运行的一个程序.是动态的过程,它有自身的产生、存在和消亡的过程。

### 2.线程

* 线程是由进程创建的，它是进程的一个实体
* 一个进程可以拥有多个线程

## 线程相关概念

1.单线程:同一时刻,只允许执行一个线程

2.多线程:同一时刻,可以执行多个线程

3.并发:同一个时刻,多个任务交替执行，单核cpu实现的任务就是并发

4.并行:同一个时刻,多个任务同时执行.多核cpu可实现并行；并发和并行可能会同时进行

## 线程的基本使用

#### 1.继承Thread

* 多线程机制

```
1.启动程序进入主方法
2.主方法创建一个主线程 
3.创建一个新线程Thread
4.启动这个新线程Thread
注意:当主线程启动这个Thread新线程,主线程不会阻塞，会继续执行
```

![image-20220601165704860](C:\Users\lzh\AppData\Roaming\Typora\typora-user-images\image-20220601165704860.png)

![image-20220601171737328](C:\Users\lzh\AppData\Roaming\Typora\typora-user-images\image-20220601171737328.png)

* start()方法

![image-20220601172649014](C:\Users\lzh\AppData\Roaming\Typora\typora-user-images\image-20220601172649014.png)

注意：start方法中的start0()方法是native方法(本地方法)，是JVM调用,底层是c/c++实现

​	然而 ，真正实现多线程的是start0()的方法，并非run()方法

![image-20220601173034990](C:\Users\lzh\AppData\Roaming\Typora\typora-user-images\image-20220601173034990.png)

#### 2.Runnable方式

![image-20220601173715736](C:\Users\lzh\AppData\Roaming\Typora\typora-user-images\image-20220601173715736.png)

通过实现Runnable接口,作为new Thread()实参,然后使用这个创建的Thread调用start()方法。

这个底层是使用了静态代理模式。

注意:Thread 类代理了继承Runnable的A类，代理了A类，把A类实例作为实参传入,调用start0()方法开启新线程状态,新线程执行A类的run方法;

#### 3.线程终止

```
1.当线程完成任务后,会自动退出
2.还可以通过使用变量来控制run方法退出的方式停止线程,即通知方式
```

#### 4.线程常用方法

```
1.start//线程开始执行,调用native方法start0(),开启新线程

2.run//调用线程run()方法

3.setPriority //更改线程优先级（ 1低 5中 10高）

4.getPriority //获取线程优先级

5.sleep//休眠
 
6.interrupt//中断,未真正结束线程,一般用于中断正在休眠线程

7.yield(静态方法):线程礼让。让出CPU，让其他线程执行,但是礼让的事件不确定,所以也不一定礼让成功

8.join:线程的插队。插队的线程一旦插队成功,则肯定先执行完插入的线程所有的任务
- 案例
创建一个子线程,每隔1s,输出hello，输出20次，主线程每隔1秒,输出hi,输出20次.要求:两个线程同时执行,当主线程输出5次后,就让子线程运行完毕,主线程再继续
```

#### 5.用户线程和守护线程

1.用户线程:也叫工作线程,当线程的任务执行完或以通知方式结束

2.守护线程:一般为工作线程服务的,当所有的用户线程结束,守护线程自动结束

3.常见的守护线程:垃圾回收机制

4.应用案例:将一个线程设置为守护线程

```java
thread02.setDaemon(true);
```

#### 6.线程的生命周期(Thread.State)

```
NEW:尚未启动的线程处于此转台
RUNNABLE:在Java虚拟机中执行的线程处于此状态

BLOCKED:被阻塞等待监视器锁定的线程处于此状态
WAITING:正在等待另一个线程执行特定动作的线程处于此状态
TIMED_WATING:正在等待另一个线程执行动作达到指定等待事件的线程处于此状态
TERMINATED:已退出
```

RUNNABLE(细分为就绪和运行状态)

![image-20220602142927622](C:\Users\lzh\AppData\Roaming\Typora\typora-user-images\image-20220602142927622.png)

* 注意:Runnable状态线程不是立即执行,而是可执行状态,需要内核线程调度器去调度来执行

#### 7.线程同步状态

##### 7.1 Synchronized *线程同步机制*

1.在多线程编程,一些敏感数据不允许被多个线程同时访问,此时就使用同步访问技术，保证数据在任何时刻,最多有一个线程访问,以保证数据的完整性。

2.线程同步,即当有一个线程在对内存操作时,其他线程都不可以对这个内存地址进行操作,知道该线程完成操作,其他线程才能对该内存地址进行操作。

![image-20220602151622427](C:\Users\lzh\AppData\Roaming\Typora\typora-user-images\image-20220602151622427.png)

#### 8.互斥锁

1.Java中引入对象互斥锁的概念,保证共享数据操作的完整性

2.每个对象都对应于一个可称为"互斥锁"的标记,这个标记用来保证在任一时刻,只能有一个线程访问该对象

3.关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任意时刻都只能由一个线程访问。

4.同步方法的局限:导致程序执行效率变低

5.同步方法(非静态)可以是某一个对象

6.静态同步方法锁即该类本身

#### 9.线程死锁 

* 多个线程都占用了对方的锁资源,但不肯相让,导致了死锁,在编程是一定要避免死锁的发生.

#### 10.释放锁

1.当前线程的同步方法、同步代码执行结束;

2.当前线程在同步代码块、同步方法中遇到break、return。

3.当线程在同步代码块、同步方法中出现了未处理的Error或Exception,导致异常结束;

4.当前线程在同步代码块\同步方法中执行了线程对象的wait()方法,当前程序暂停,并释放锁。

* 下面的操作不会释放锁

  1.yield()和sleep()不会释放锁。

  2.线程执行同步代码块时,其他线程调用了该线程的suspend()方法将该线程挂起,该线程不会释放锁。
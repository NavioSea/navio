## 一、通过事件间接联系的监听器（实现了事件解耦）

#### ApplicationListener

#### 1.事件类型ApplicationEvent

* 自定义事件类型

```java
public class SendMessageEvent extends ApplicationEvent {
	/**
	 * Create a new ApplicationEvent.
	 *
	 * @param source the object on which the event initially occurred (never {@code null})
	 */
	public SendMessageEvent(Object source) {
		super(source);
		log.info("企业微信群发送消息事件推送成功");
	}
}

```

#### 2.事件发布器ApplicationEventPublisher

```java
//实际上是一个ApplicationContext
@Autowired
private ApplicationEventPublisher publisher;

public void dobusiness(){
 	publisher.publishEvent(new SendMessageEvent("内容"));
}
```

### 监听器1

#### 3.事件监听器AoolicationListener<T>:一个事件发布器可以有多个监听器，

#### 同时,实现了事件解耦

 ````java
@Slf4j
@Component
public class SendMessageListener implements ApplicationListener<SendMessageEvent> {


	@Autowired
	private RabbitTemplate rabbitTemplate;

	@Override
	public void onApplicationEvent(SendMessageEvent event) {
		Tenant tenant = (Tenant) event.getSource();
		ResourceEnableApprovalRequest resourceEnableApprovalRequest = new ResourceEnableApprovalRequest();
		resourceEnableApprovalRequest.setCustomerName(tenant.getTenantName());
		resourceEnableApprovalRequest.setDomain(tenant.getDomain());
		resourceEnableApprovalRequest.setCelphone(tenant.getContactNumber());
		resourceEnableApprovalRequest.setEmail(tenant.getEmail());
		resourceEnableApprovalRequest.setStatus(0);
		String md =
			"### 客户“" + tenant.getTenantName() + "”注册平台通知！\n" +
			"> 租户子域名：" + tenant.getDomain() + "\n" +
			"> 手机号：" + tenant.getContactNumber() + "\n" +
			"> 邮箱：" + tenant.getEmail();
		resourceEnableApprovalRequest.setMessageContent(md);
		rabbitTemplate.convertAndSend(QUEUE_QYWX,QUEUE_GROUP_WEB_HOOK,resourceEnableApprovalRequest);
		log.info("发送消息事件完成");
	}

 ````

### 监听器2

#### 1.通过@EventListener 注解实现监听

```java
@Component
static class Service(){
	@EventListener
	public void listener(SendMessageEvent myEvent){
		log.info("监听实例")
	}
}
```

## 二、异步实现事件监听器()

#### 1.创建异步的线程池

```java
@Bean 
public ThreadPoolTaskExecutor executor(){
    //创建线程池
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); 
    executor.setCorePoolSize(3);
    executor.setMaxPoolSize(10);
    executor.setQueueCapacity(100);
    return executor;
}
```

#### 2.SimpleApplicationEventMuticaster(事件广播器) 默认单线程发送,需要使用多线程，需要用配置取代（方法名:applicationEventMuticaster）

```java
@Bean 
public SimpleApplicationEventMuticaster applicationEventMuticaster(ThreadPoolTaskExecutor executor){
   SimpleApplicationEventMuticaster muticaster = new SimpleApplicationEventMuticaster();
    muticaster.setTaskExecutor(executor);
    return muticaster;
}
```

#### 3.@EventListener原理 

![image-20220606012819303](C:\Users\lzh\AppData\Roaming\Typora\typora-user-images\image-20220606012819303.png)

   

#### 4.监听器GenericApplicationListener



